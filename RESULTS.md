Originally we wanted to take a dataset from the Stanford Open Dataset Collection, specifically the Stanford.edu webpages collection dataset and run our three chosen algorithms: BFS, Dijstra’s, and Landmark, on the webpages collection to find the shortest path between two webpages in the collection. However, after meeting with our project mentor and discussing the viability of our chosen dataset as well as how our three chosen algorithms would traverse the data, we decided to make some changes to our project in order to have a fully functional deliverable. So we decided to overhaul our project and proposed a new leading question that would take a new dataset and three algorithms. We decided to take our new dataset from the Open Flights dataset and took three algorithms to apply to the dataset: BFS, Dijkstra’s, and Landmark. We took our new leading question to be if given our dataset, could our three algorithms find the shortest path between two airports of our choosing?

Before even being able to write the code for the traversals, we needed to make the Open Flights Route data useful for us. We began by reading in the CSV file of route data and parsing it in a way to just have source airports and destination airports. Upon completing this first task, we then had to discern how to visualize our data as a directed graph and implement that in our codebase. This led us to creating our Graph class and Edge struct. Once our data was in a useful format we could begin development of our three algorithms. 

The BFS development was easy to build as we had previously implemented the algorithm on a tree data structure in one of our MPs. However, we had to make a few adjustments In order to make it work on our specific graph data structure. We created a list(queue) that pushes and pops each node to be visited as well as store the visited nodes. While processing each entry while the queue is not empty, we check the adjacency list to find all nodes connected to the current node and add them onto the queue and mark them as visited. Thus, having the adjacency list makes the system much easier as it marks all the incident nodes. Overall, our implementation managed to get the shortest possible run time of O(n + m). In the end, we implement a print function that displays the traversal through the nodes using BFS.

In implementing Dijkstra’s algorithm, we drew inspiration from the pseudocode on Wikipedia and the code explained during lecture and improvised on that to better fit our model. We allocate unordered maps to store the distances from one node to another, the shortest distance from the starting node to any node as well as the path taken while traversing. As we loop through the nodes, we figure out the minimum distance between the current node and any of its adjacent nodes and we update the distance map, based on the weights on each edge (Here, the distance between two locations) and the minimum distance found above. Finally, we update the distances, store the path of traversal and in the end reverse the path to get our shortest path from Dijkstra's. Overall, our dijkstra’s algorithm runtime came out to be O( m*logn ) which is the best possible run time we could have made without using a Fibonacci heap, we then call the print function to print the path.

For the Landmark algorithm, we wanted to figure out a way to add a connecting airport/location during someone’s travel and still find the shortest route someone can take. In order to do this, we decided to utilize our previous algorithm of Dijkstra’s to find the shortest path to and from the connecting airport between the start and endpoints. This way we just had to merge the two paths and remove redundancies (like an extra node for the connecting airport) to get our final shortest path through the connection. Our runtime of Landmark is fairly simple to evaluate as running Dijkstra’s twice gives us a combined runtime of O( m*logn ) itself. Note that merging the two paths will take an O(k) time where k is the number of nodes in the path, but since this k << (m or n) it can be ignored. Finally, we then call the relevant print function to print the path obtained by our Landmark algorithm. 

Based on our test cases, and our analysis of our datasets, we know that our algorithms are all working as intended as all three of BFS, Dijkstra’s, and Landmark all output the correct string of airports that represents the shortest possible path between two airports of our choosing in accordance to the dataset that we implemented the programs for
